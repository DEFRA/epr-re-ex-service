# Summary Log Preview Integrity

This document describes how the system ensures that the preview shown to users before confirming a summary log submission accurately reflects what will happen when they confirm.

For related context, see:

- [Summary Log Submission LLD](./summary-log-submission-lld.md) - full submission workflow
- [ADR 21: Idempotent Operations](../decisions/0021-idempotent-operations-and-retry-mechanisms.md) - resilience patterns

<!-- prettier-ignore-start -->
<!-- TOC -->

- [Summary Log Preview Integrity](#summary-log-preview-integrity)
  - [Goals](#goals)
  - [Problem statement](#problem-statement)
    - [Problem 1: Stale preview](#problem-1-stale-preview)
    - [Problem 2: Validation reading partial data](#problem-2-validation-reading-partial-data)
    - [Problem 3: Abandoned previews](#problem-3-abandoned-previews)
  - [Key constraint](#key-constraint)
  - [Solution](#solution)
    - [Mechanism 1: Supersede on new upload](#mechanism-1-supersede-on-new-upload)
    - [Mechanism 2: Block uploads during submission](#mechanism-2-block-uploads-during-submission)
    - [Mechanism 3: Verify still current on confirm](#mechanism-3-verify-still-current-on-confirm)
  - [How the mechanisms work together](#how-the-mechanisms-work-together)
  - [Scenarios](#scenarios)
    _ [Scenario 1: User confirms promptly](#scenario-1-user-confirms-promptly)
    _ [Scenario 2: Another user uploads before confirm](#scenario-2-another-user-uploads-before-confirm)
    _ [Scenario 3: Another user tries to upload during submission](#scenario-3-another-user-tries-to-upload-during-submission)
    _ [Scenario 4: User abandons preview](#scenario-4-user-abandons-preview)
    <!-- TOC -->
    <!-- prettier-ignore-end -->

## Goals

The system must achieve three goals:

1. **Accurate previews**: The preview shown to users must accurately reflect what will happen when they confirm
2. **No partial data reads**: Validation must not read partially-updated waste records during another submission
3. **No stuck states**: An abandoned preview must not block other users from uploading

These goals are in tension. Blocking uploads during submission (goal 2) could cause stuck states if submission fails. Allowing uploads at any time could produce inaccurate previews (goal 1) or read partial data (goal 2). The solution must balance all three.

## Problem statement

### Problem 1: Stale preview

When a user uploads a summary log, they see a preview showing what will happen when they confirm:

- **Added**: New waste records that will be created
- **Adjusted**: Existing records that will be updated
- **Unchanged**: Records that match existing data

The preview is generated by comparing the uploaded summary log against the current state of waste records. If those waste records change before the user confirms, the preview becomes inaccurate.

### Problem 2: Validation reading partial data

Summary log submission involves bulk-writing potentially thousands of waste record versions. This operation takes time. If another user uploads a summary log while submission is in progress, the validation phase (which reads waste records to generate the preview) could read partially-updated data, producing an incorrect preview.

### Problem 3: Abandoned previews

A user might upload a summary log, see the preview, and then never confirm - they might close the browser, go on holiday, or simply decide not to proceed. If the system blocked other users from uploading while a preview exists, organisations could become stuck indefinitely.

## Key constraint

**Summary log submission is the only way to modify waste records.**

This constraint simplifies the integrity problem: the only way waste records can change is via another summary log submission for the same organisation/registration pair.

## Solution

Three mechanisms work together to ensure preview integrity:

### Mechanism 1: Supersede on new upload

When a new summary log is uploaded for an organisation/registration pair, all previous unsubmitted logs for that pair are marked as `superseded` (a terminal state).

```javascript
// On upload: supersede unsubmitted logs
await updateMany(
  {
    organisationId,
    registrationId,
    status: { $in: ['preprocessing', 'validating', 'validated'] }
  },
  { $set: { status: 'superseded' } }
)
```

**Effect**: If User A has a validated preview and User B uploads a new summary log, User A's log becomes superseded. User A cannot confirm a stale preview because their log is no longer in a confirmable state.

### Mechanism 2: Block uploads during submission

When a submission is in progress for an organisation/registration pair, new uploads for that pair are blocked.

```javascript
// On upload: check for active submission
const submitting = await findOne({
  organisationId,
  registrationId,
  status: 'submitting'
})
if (submitting) {
  throw Boom.conflict('A submission is in progress. Please wait.')
}
```

**Effect**: While waste records are being updated, no new uploads can start. This prevents the validation phase from reading partially-updated waste records.

### Mechanism 3: Verify still current on confirm

Before processing a confirmation, the system verifies the summary log is still the current validated log for its organisation/registration pair.

```javascript
// On confirm: verify still current
const currentLog = await findOne({
  organisationId,
  registrationId,
  status: 'validated'
})
if (!currentLog || currentLog.id !== submittedLogId) {
  throw Boom.conflict('A newer summary log has been uploaded')
}
```

**Effect**: Race condition protection. Even if superseding happened between the user clicking confirm and the request arriving, the confirmation is rejected.

## How the mechanisms work together

```mermaid
flowchart TD
    subgraph "Upload Phase"
        A[User uploads summary log] --> B{Submission in progress<br/>for org/reg?}
        B -->|Yes| C[Block: 'Please wait']
        B -->|No| D[Supersede existing<br/>unsubmitted logs]
        D --> E[Process upload & validate]
        E --> F[Show preview to user]
    end

    subgraph "Confirm Phase"
        F --> G[User clicks Confirm]
        G --> H{Log still current<br/>for org/reg?}
        H -->|No| I[Error: 'Newer upload exists']
        H -->|Yes| J[Transition to 'submitting']
        J --> K[Block new uploads for org/reg]
        K --> L[Bulk update waste records]
        L --> M[Mark as 'submitted']
    end
```

## Scenarios

### Scenario 1: User confirms promptly

```mermaid
sequenceDiagram
    participant User
    participant API
    participant DB

    User->>API: Upload summary log
    API->>DB: Create log (status: validated)
    API-->>User: Preview: 5 added, 3 adjusted

    User->>API: Confirm
    API->>DB: Verify log still current ✓
    API->>DB: Update waste records
    API-->>User: Success
```

**Outcome**: Preview matches result. No integrity issues.

### Scenario 2: Another user uploads before confirm

```mermaid
sequenceDiagram
    participant UserA
    participant UserB
    participant API
    participant DB

    UserA->>API: Upload summary log A
    API->>DB: Create log A (status: validated)
    API-->>UserA: Preview: 5 added, 3 adjusted

    Note over UserA: User A goes for lunch

    UserB->>API: Upload summary log B
    API->>DB: Supersede log A
    API->>DB: Create log B (status: validated)
    API-->>UserB: Preview: 2 added, 6 adjusted

    UserB->>API: Confirm log B
    API->>DB: Update waste records
    API-->>UserB: Success

    Note over UserA: User A returns

    UserA->>API: Confirm log A
    API->>DB: Verify log A still current ✗
    API-->>UserA: Error: Newer upload exists
```

**Outcome**: User A cannot confirm stale preview. They must re-upload to see the current state.

### Scenario 3: Another user tries to upload during submission

```mermaid
sequenceDiagram
    participant UserA
    participant UserB
    participant API
    participant DB

    UserA->>API: Upload & validate log A
    API-->>UserA: Preview: 5 added, 3 adjusted

    UserA->>API: Confirm log A
    API->>DB: Status → submitting
    API->>DB: Begin updating waste records...

    UserB->>API: Upload summary log B
    API->>DB: Check for submitting status
    API-->>UserB: Error: Submission in progress

    API->>DB: Finish updating waste records
    API->>DB: Status → submitted

    UserB->>API: Upload summary log B (retry)
    API->>DB: No submission in progress ✓
    API-->>UserB: Preview reflects User A's changes
```

**Outcome**: User B cannot generate a preview from partial data. They must wait, then their preview reflects the completed submission.

### Scenario 4: User abandons preview

```mermaid
sequenceDiagram
    participant UserA
    participant UserB
    participant API
    participant DB

    UserA->>API: Upload summary log A
    API->>DB: Create log A (status: validated)
    API-->>UserA: Preview: 5 added, 3 adjusted

    Note over UserA: User A closes browser<br/>and goes on holiday

    Note over UserB: Days later...

    UserB->>API: Upload summary log B
    API->>DB: Supersede log A
    API->>DB: Create log B (status: validated)
    API-->>UserB: Preview: 2 added, 6 adjusted

    UserB->>API: Confirm log B
    API->>DB: Update waste records
    API-->>UserB: Success
```

**Outcome**: User A's abandoned preview does not block User B. The supersede mechanism allows new uploads at any time (except during active submission), preventing stuck states.
